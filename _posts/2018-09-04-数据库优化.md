---
title: "数据库优化"
date: 2018-09-04 12:40
categories: python
tags: 面试
---

## 数据库部分

### **1.1数据库的分类及常用的数据库**

​      数据库分为：关系型数据库和非关系型数据库

​          关系型：mysql oracle sqlserver等

​          非关系型：redis,memcache,mongodb,hadoop等

关系型数据库

1.表和表、表和字段、数据和数据存在着关系

优点:

1.数据之间有关系，进行数据的增删改查的时候是非常方便的

2.关系型数据库是有事务操作的，保证数据的完整性和一致性。

缺点：

1.因为数据和数据是有关系的，底层是运行了大量的算法

大量算法会降低系统的效率，会降低性能

2.面对海量数据的增删改查的时候会显的无能为力

3.海量数据对数据进行维护变得非常的无力

适合处理一般量级的数据（银行转账和钱）

非关系数据库的（redis和MangDB）

为了处理海量数据，非关系数据库设计之初就是为了替代关系型数据库的关系

优点：

1.海量数据的增删改查是可以的

2.海量数据的维护和处理非常轻松

缺点：

1.数据和数据没有关系，他们之间就是单独存在的

2.非关系数据库没有关系，没有强大的事务关系，没有保证数据的完整性和安全性

适合处理海量数据，保证效率，不一定安全（统计数据，例如微博数据）



### **1.2简单介绍一下****关系数据库****三范式？**

范式就是规范,就是关系型数据库在设计表时，要遵循的三个规范。

***要想满足第二范式必须先满足第一范式，要满足第三范式必须先满足第二范式。***

 

第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。列数据的不可分割

 

二范式（2NF）要求数据库表中的每个行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。(主键)

 

满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。(外键)

 

反三范式,有的时候为了效率，可以设置重复或者可以推导出的字段.

​        订单（总价）和订单项（单价）

 

### **1.3事务四个基本特征或 ACID 特性。**

事务是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。

一个转账必须 A账号扣钱成功，B账号加钱成功，才算正真的转账成功。

  事务必须满足四大特征:

 **原子性**：表示事务内操作不可分割。要么都成功、要么都是失败.

 **一致性**：要么都成功、要么都是失败.后面的失败了要对前面的操作进行回滚。

 **隔离性**：一个事务开始后，不能后其他事务干扰。

 **持久性/持续性**：表示事务开始了，就不能终止。

### **1.4 mysql数据库的默认的最大连接数？**

100 

 为什么需要最大连接数？特定服务器上面的数据库只能支持一定数目同时连接，这时候我们一般都会设置最大连接数（最多同时服务多少连接）。在数据库安装时都会有一个默认的最大连接数为100

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsF3AF.tmp.jpg) 

 

### **1.5说一下msyql的分页？Oracle的分页？**

为什么需要分页？在很多数据是，不可能完全显示数据。进行分段显示.

 

Mysql是使用关键字limit来进行分页的 limit offset,size 表示从多少索引去多少位.

Oracle的分页，大部分情况下，我们是记不住了。说思路，要使用三层嵌套查询。

   Oracle的分页有点儿记不住了，只记得一些大概。是使用了三层嵌套查询。如果在工作中使用了，可以到原来的项目中拷贝或上网查询。

```mysql
mysql:
	String sql = 
	"select * from students order by id limit " + pageSize*(pageNumber-1) + "," + pageSize;
	
oracle:
	String sql = 
	 "select * from " +  
	 (select *,rownum rid from (select * from students order by postime desc) where rid<=" + pagesize*pagenumber + ") as t" + 
	 "where t>" + pageSize*(pageNumber-1);
```



 

### **1.6简单讲一下数据库的触发器的使用场景？**

触发器，需要有触发条件，当条件满足以后做什么操作。

 

触发器用处还是很多的，比如校内网、开心网、Facebook，你发一个日志，自动通知好友，其实就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高。而UCH没有用触发器，效率和数据处理能力都很低。

 

每插入一个帖子，都希望将版面表中的最后发帖时间，帖子总数字段进行同步更新，用触发器做效率就很高。

 

 

 

### **1.7 简单讲一下数据库的存储过程的使用场景？**

数据库存储过程具有如下优点：

1、存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。

2、通常，复杂的业务逻辑需要多条 SQL 语句。这些语句要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会大大减少，降低了网络负载。

3、存储过程创建一次便可以重复使用，从而可以减少数据库开发人员的工作量。

4、安全性高，存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，无需拥有访问底层数据库对象的显式权限。

 

正是由于存储过程的上述优点，目前常用的数据库都支持存储过程，例如 IBM DB2，Microsoft SQL Server，Oracle，Access 等，开源数据库系统 MySQL 也在 5.0 的时候实现了对存储过程的支持。

 

定义存储过程:

```mysql
create procedure insert_Student (_name varchar(50),_age int ,out _id int)
begin
	insert into student value(null,_name,_age);
	select max(stuId) into _id from student;
end;

call insert_Student('wfz',23,@id);
select @id;
```



## 数据库优化



如何定位： 查找慢查询并定位。

​	在项目自验或项目转测试之前，在启动mysql数据库时开启慢查询，并且把执行慢的语句写到日志中，在运行一定的时间后，通过查看日志找到慢查询语句。

​	使用explain + 慢查询语句，详细分析语句的问题。

 做过mysql数据库的优化、其他数据库类似

定位：查找、定位慢查询

- 创建索引：创建合适的索引，我们就可以先在索引中查询，查询到以后直接找对应的记录
- 分表： 当一张表的数据比较多或者一张表的某些字段的值比较多，并且很少使用时。采用水平分表和垂直分表来优化。
- 读写分离：当一台服务器不能满足需求时，采用读写分离的方式进行集群。
- 缓存：使用redis，来进行缓存。
- 一些常用优化技巧

 

   **2.6 查找慢查询并定位慢查询？**

要找出项目中的慢Sql时

1、关闭数据库服务器(关闭服务)

2、把慢查询记录到日志中

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE09.tmp.jpg) 

3、设置慢查询时间

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE19.tmp.jpg) 

4、找出日志中的慢查询SQL

  

   使用explain 慢查询语句，来详细分析语句的问题.

 

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE1A.tmp.jpg) 

 

 

### **2.6 数据库优化之遵循范式？**

 数据库表设计时需要遵循方式

 表的范式，是首先符合1NF, 才能满足2NF , 进一步满足3NF

1NF: 即表的列的具有原子性,不可再分解，即列的信息，不能分解.只要数据库是关系型数据库(mysql/oracle/db2/sysbase/sql server)，就自动的满足1NF.关系型数据库中是不允许分割列的。

2NF:表中的记录是唯一的.通常我们设计一个主键来实现

3NF:即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放.(外键)

反3NF :没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余**。** 订单和订单项、相册浏览次数和照片的浏览次数

### **2.7** **选择合适的存储引擎**

在开发中，我们经常使用的存储引擎 myisam / innodb/ memory

MyISAM存储引擎

如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. 比如 bbs 中的 发帖表，回复表.

 

INNODB存储引擎: 

对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表.

 

Memory 存储

​	我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory, 速度极快.

 

问 MyISAM 和 INNODB的区别(主要)

1. 事务安全 myisam不支持事务而innodb支持
2. 查询和添加速度 myisam不用支持事务就不用考虑同步锁，查找和添加和添加的速度快
3. 支持全文索引 myisam支持innodb不支持
4. 锁机制 myisam支持表锁而innodb支持行锁(事务)
5. 外键 MyISAM 不支持外键， INNODB支持外键. (通常不设置外键，通常是在程序中保证数据的一致)

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE1B.tmp.jpg) 

 

 

 

 

### **2.8 数据库优化之创建合适的索引?**

**索引（Index）是帮助****DBMS****高效获取数据的数据结构****。**

分类：普通索引/唯一索引/主键索引/全文索引

普通索引:允许重复的值出现

唯一索引:除了不能有重复的记录外，其它和普通索引一样(用户名、用户身份证、email,tel)

主键索引：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会給改列创建索引。这就是主键索引.唯一且没有null值

全文索引:用来对表中的文本域(char，varchar，text)进行索引， 全文索引针对MyIsam

explain select * from articles where match(title,body) against(‘database’);【会使用全文索引】

### **2.9 索引使用小技巧？\*******

索引弊端

1.占用磁盘空间。

2.对dml(插入、修改、删除)操作有影响，变慢。

使用场景：

a: 肯定在where条件经常使用,如果不做查询就没有意义

b: 该字段的内容不是唯一的几个值(sex) 

c: 字段内容不是频繁变化.

 

具体技巧：

1. 对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引。

alter table dept add index my_ind (dname,loc); // dname 左边的列,loc就是右边的列

explain select * from dept where dname='aaa'\G 会使用到索引

explain select * from dept where loc='aaa'\G 就不会使用到索引

 

\2. 对于使用like的查询，查询如果是’%aaa’不会使用到索引而‘aaa%’会使用到索引。

   explain select * from dept where dname like '%aaa'\G不能使用索引

   explain select * from dept where dname like 'aaa%'\G使用索引.

所以在like查询时，‘关键字’的最前面不能使用 % 或者 _这样的字符.，如果一定要前面有变化的值，则考虑使用 全文索引->sphinx.

 

3. 如果条件中有or，有条件没有使用索引,即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段,都必须单独使用时能使用索引.

   

 

4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。

expain select * from dept where dname=’111’;

expain select * from dept where dname=111;（数值自动转字符串）

expain select * from dept where dname=qqq;报错

也就是，如果列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来.

5. 如果mysql估计使用全表扫描要比使用索引快，则不使用索引。

   表里面只有一条记录

 

### **2.10 数据库优化之分表？**

分表分为水平(按行)分表和垂直(按列)分表

 

根据经验，Mysql表数据一般达到百万级别，查询效率会很低，容易造成表锁，甚至堆积很多连接，直接挂掉；**水平分表**能够很大程度较少这些压力。

按行数据进行分表。

 

如果一张表中某个字段值非常多(长文本、二进制等)，而且只有在很少的情况下会查询。这时候就可以把字段多个单独放到一个表，通过外键关联起来。

​     考试详情，一般我们只关注分数，不关注详情。

水平分表策略：

1.按时间分表

这种分表方式有一定的局限性，当数据有较强的实效性，如微博发送记录、微信消息记录等，这种数据很少有用户会查询几个月前的数据，如就可以按月分表。

2.按区间范围分表

一般在有严格的自增id需求上，如按照user_id水平分表：

table_1  user_id从1~100w 

table_2  user_id从101~200w 

table_3  user_id从201~300w 

3.hash分表*****

通过一个原始目标的ID或者名称通过一定的hash算法计算出数据存储表的表名，然后访问相应的表。

### **2.11 数据库优化之读写分离**

一台数据库支持的最大并发连接数是有限的，如果用户并发访问太多。一台服务器满足不要要求是就可以集群处理。Mysql的集群处理技术最常用的就是读写分离。	

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE1C.tmp.jpg) 

主从同步

数据库最终会把数据持久化到磁盘，如果集群必须确保每个数据库服务器的数据是一直的。**能改变数据库数据的操作都往主数据库去写**，**而其他的数据库从主数据库上同步数据。**

读写分离

   使用负载均衡来实现写的操作都往主数据去，而读的操作往从服务器去。

### **2.12 数据库优化之缓存**

 	在持久层(dao)和数据库(db)之间添加一个缓存层，如果用户访问的数据已经缓存起来时，在用户访问时直接从缓存中获取，不用访问数据库。而缓存是在操作内存级，访问速度快。

 

作用：减少数据库服务器压力，减少访问时间。

 

Java中常用的缓存有，

   1、hibernate的二级缓存。该缓存不能完成分布式缓存。

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE1D.tmp.jpg) 

2、可以使用redis(memcahe等)来作为中央缓存。

​        对缓存的数据进行集中处理

### **2.13 语句优化小技巧**

DDL优化:

1 、通过禁用索引来提供导入数据性能 。 这个操作主要针对有数据库的表，追加数据

//去除键

alter table test3 DISABLE keys;

//批量插入数据

insert into test3 select * from test;

//恢复键

alter table test3 ENABLE keys;

 

2、 关闭唯一校验

set unique_checks=0  关闭

set unique_checks=1  开启

 

3、修改事务提交方式(导入)（变多次提交为一次）

set autocommit=0   关闭

//批量插入

set autocommit=1   开启

DML优化（变多次提交为一次）	

insert into test values(1,2);

insert into test values(1,3);

insert into test values(1,4);

//合并多条为一条

insert into test values(1,2),(1,3),(1,4)

DQL优化

Order by优化

 		1、多用索引排序

2、普通结果排序（非索引排序）Filesort

   group by优化

​      是使用order by null,取消默认排序

   子查询优化

在客户列表找到不在支付列表的客户

\#在客户列表找到不在“支付列表”的客户 , 查询没买过东西的客户

explain

select * from customer where customer_id not in (select DISTINCT customer_id from payment); #子查询      -- 这种是基于func外链

 

explain 

select * from customer c left join payment p on(c.customer_id=p.customer_id) where p.customer_id is null   -- 这种是基于“索引”外链

   Or优化

在两个独立索引上使用or的性能优于 

1、 or两边都是用索引字段做判断，性能好！！

2、 or两边，有一边不用，性能差

3、 如果employee表的name和email这两列是一个复合索引，但是如果是 :name='A' OR email='B' 这种方式，不会用到索引！

  limit优化

select film_id,description from film order by title limit 50,5;

 

select a.film_id,a.description from film a inner join (select film_id from film order by title limit 50,5)b on a.film_id=b.film_id

 

 

 

### **2.14 jdbc批量插入几百万数据怎么实现？\*******

1、变多次提交为一次

3、使用批量操作

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE1E.tmp.jpg) 

 

省出的时间可观。

 

像这样的批量插入操作能不使用代码操作就不使用，可以使用存储过程来实现。

### **2.15 有没有使用过redis? Redis是什么**  

 

Redis是一个key-value的nosql数据库.先存到内存中，会根据一定的策略持久化到磁盘,即使断电也不会丢失数据。支持的数据类型比较多。

 

主要用来做缓存数据库的数据和web集群时当做中央缓存存放seesion

 

**2.4.15 Redis和memche的比较?** 

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE1F.tmp.jpg) 

 

1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。

2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。

3、虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘

   

### **2.16 简单说一下redis的使用场景？**	

缓存：

把经常需要查询的、很少修改数据，放到读速度很快的空间(内存)，以便下次访问减少时间。减轻压力，减少访问时间.

计数器：

​     redis中的计数器是原子性的内存操作。	

​       可以解决库存溢出问题.进销存系统库存溢出。		

session缓存服务器：

web集群时作为session缓存服务器

![img](file:///C:\Users\rick\AppData\Local\Temp\ksohtml\wpsBE20.tmp.jpg) 

缓存队列等

### **2.17 redis对象保存方式？**

Json字符串:

需要把对象转换为json字符串，当做字符串处理。直接使用set get来设置或者或。

优点：设置和获取比较简单

缺点：没有提供专门的方法，需要把把对象转换为json。(jsonlib)

字节:

   需要做序列号，就是把对象序列化为字节保存。

 

如果是担心JSON转对象会消耗资源的情况，这个问题需要考量几个地方，

第一点：就是使用的JSON转换lib是否就会存在性能问题。

第二点：就是数据的数据量级别，如果是存储百万级的大数据对象，建议采用存储序列化对象方式。如果是少量的数据级对象，或者是数据对象字段不多，还是建议采用JSON转换成String方式。

毕竟redis对存储字符类型这部分优化的非常好。具体采用的方式与方法，还要看你所使用的场景。

 

 

### **2.18 Redis数据淘汰机制**

在 redis 中，允许用户设置最大使用内存大小 server.maxmemory，在内存限定的情况下是很有用的。譬如，在一台 8G 机子上部署了 4 个 redis 服务点，每一个服务点分配 1.5G 的内存大小，减少内存紧张的情况，由此获取更为稳健的服务。

 

内存大小有限，需要保存有效的数据?

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

redis 提供 6种数据淘汰策略：

 

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近**最少使用的数据淘汰**

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

**allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰**

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

 

 

### **2.19 Java访问Redis**

1、使用jedis java客户端来访问redis服务器，有点类似通过jdbc访问mysql一样。

2、当然如果是spring进行集成时，可以使用spring data来访问redis,spring data只是对jedis的二次封装。jdbcTemplate jdbc关系一样

### **2.20 Redis集群**

当一台数据无法满足要求，可以使用reids集群来处理，类似于mysql的读写分离。